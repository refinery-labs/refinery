_VERSION = "1.0.0"

"""
Base redis connection for pulling configs/etc.

Allows for single-millisecond retrieval and setting
of data in the main redis memory cache.
"""
import os
import uuid
import json
import time
import redis
import pickle
import traceback

# TODO only initialize connection when used.
class Refinery_Memory:
	json_types = [
		list,
		dict
	]
	
	regular_types = [
		str,
		int,
		float,
		complex,
		bool,
	]
	
	def __init__( self, in_hostname, in_password, namespace ):
		self.redis_client = False
		self.namespace = namespace
		self.hostname = in_hostname
		self.password = in_password
		
	def connect( self ):
		self.redis_client = redis.StrictRedis(
		    host=self.hostname,
		    port=6379,
		    db=0,
		    socket_timeout=2,
		    password=self.password,
		)
		
	def _get_namespace( self, kwargs ):
		if self.namespace == False:
			return ""

		if "raw" in kwargs and kwargs[ "raw" ]:
			return ""
			
		return self.namespace + "."
	
	def set( self, key, input_data, **kwargs ):
		if not self.redis_client:
			self.connect()
		
		namespace = self._get_namespace( kwargs )
			
		if type( input_data ) in self.regular_types:
			self.redis_client.set(
				namespace + key,
				input_data
			)
		elif type( input_data ) in self.json_types:
			self.redis_client.set(
				namespace + key,
				json.dumps(
					input_data
				)
			)
		else:
			self.redis_client.set(
				namespace + key,
				pickle.dumps(
					input_data
				)
			)
			
	def get( self, key, **kwargs ):
		if not self.redis_client:
			self.connect()
			
		namespace = self._get_namespace( kwargs )
		
		data = self.redis_client.get(
			namespace + key
		)
		
		try:
			return json.loads(
				data
			)
		except:
			pass
		
		try:
			return pickle.loads(
				data
			)
		except:
			pass
		
		return data
			
	def exists( self, key, **kwargs ):
		if not self.redis_client:
			self.connect()
			
		namespace = self._get_namespace( kwargs )
		
		return self.redis_client.exists(
			namespace + key
		)
		
	def delete( self, key, **kwargs ):
		if not self.redis_client:
			self.connect()
			
		namespace = self._get_namespace( kwargs )
		
		return self.redis_client.dek(
			namespace + key
		)
		
	def rename( self, key, new_key, **kwargs ):
		if not self.redis_client:
			self.connect()
			
		namespace = self._get_namespace( kwargs )
		
		return self.redis_client.rename(
			namespace + key,
			new_key
		)
		
	def expire_at( self, key, unix_timestamp, **kwargs ):
		if not self.redis_client:
			self.connect()
			
		namespace = self._get_namespace( kwargs )
		
		return self.redis_client.expireat(
			namespace + key,
			unix_timestamp
		)
		
	def expire_in( self, key, seconds, **kwargs ):
		if not self.redis_client:
			self.connect()
			
		namespace = self._get_namespace( kwargs )
		
		return self.redis_client.expire(
			namespace + key,
			seconds
		)
		
	def _get_input_data_from_redis( self, key, **kwargs ):
		if not self.redis_client:
			self.connect()
			
		namespace = self._get_namespace( kwargs )
		pipeline = self.redis_client.pipeline()
		pipeline.get( key )
		pipeline.delete( key )
		returned_data = pipeline.execute()
		
		try:
			return json.loads( returned_data[ 0 ] )
		except:
			pass
		
		return returned_data[ 0 ]
		
	def _store_return_data_to_redis( self, return_data, **kwargs ):
		if not self.redis_client:
			self.connect()
			
		new_key = str( uuid.uuid4() )
			
		self.redis_client.setex(
			new_key,
			( 60 * 5 ),
			json.dumps(
				return_data
			)
		)
		
		return new_key

def _init( lambda_input, context ):
	global cmemory
	global gmemory
	
	cmemory = Refinery_Memory(
		"config-memory.refinery.thehackerblog.com",
		"{{REDIS_PASSWORD_REPLACE_ME}}",
		False
	)
	
	gmemory = Refinery_Memory(
		"global-memory.refinery.thehackerblog.com",
		"{{REDIS_PASSWORD_REPLACE_ME}}",
		context.function_name
	)
	
	transition_data = json.loads( "{{TRANSITION_DATA_REPLACE_ME}}" )
	
	return_key = gmemory._store_return_data_to_redis({
		"pew": "pew",
		"kew": "ok"
	})
	
	return gmemory._get_input_data_from_redis(
		return_key
	)
	
	#result = main( lambda_input, context )
	
	return {
		"_refinery": {
			"indirect": false,
			"input_data": {
				"": ""
			}
		}
	}
	
	"""
	_lambda_client = boto3.client( "" )
	
	response = client.invoke(
	    FunctionName='string',
	    InvocationType='Event'|'RequestResponse'|'DryRun',
	    LogType='None'|'Tail',
	    ClientContext='string',
	    Payload=b'bytes'|file,
	    Qualifier='string'
	)
	"""