backpack = {};

function return_result( program_output ) {
	console.log(
		"<REFINERY_OUTPUT_CUSTOM_RUNTIME_START_MARKER>" + JSON.stringify(
			program_output,
			false,
			4
		) + "<REFINERY_OUTPUT_CUSTOM_RUNTIME_END_MARKER>"
	);
}

(async function refinerySubproccessWrapper() {

	var input_data = JSON.parse( process.argv[2] );
	var lambda_input = input_data[ "lambda_input" ];
	backpack = input_data[ "backpack" ];
	try {
		var output = await main( lambda_input );
		return_result({
			"output": output,
			"backpack": backpack,
		});

		backpack = {};

		exeunt__refinery(0);
	} catch ( e ) {
		if( e.stack ) {
			e = e.stack.toString()
		} else {
			e = e.toString();
		}
		console.log(
			"<REFINERY_ERROR_OUTPUT_CUSTOM_RUNTIME_START_MARKER>" + JSON.stringify({
				"output": e,
				"backpack": backpack
			}) + "<REFINERY_ERROR_OUTPUT_CUSTOM_RUNTIME_END_MARKER>"
		);
		backpack = {};

		exeunt__refinery(-1);
	}
})();

var NODE_MINOR_VER_WITHOUT_PROCESS_EXIT_CODE = 10;

function setBlocking__refinery() {
	[process.stdout, process.stderr].forEach(function setStreamBlocking(s) {
		if (s && s._handle && s._handle.setBlocking) {
			s._handle.setBlocking(true);
		}
	});
}


/*
 * A "soft" version of `process.exit([code])` that will avoid actually using
 * `process.exit` if possible -- only if exiting non-zero and with an older
 * version of node (<= 0.10) that doesn't yet support `process.exitCode`.
 *
 * See the discussion in "Solution 1" of the README.md.
 *
 * Usage:
 *      var exeunt = require('exeunt');
 *      // ...
 *      exeunt.softExit(code);
 *      return;
 *
 * @param {Number} code - Optional exit code. Defaults to 0.
 */
function softExit__refinery(code) {
	var exitCode = code || 0;
	var nodeVer = process.versions.node.split('.').map(Number);
	var supportsProcessExitCode = true;

	if (nodeVer[0] === 0
		&& nodeVer[1] <= NODE_MINOR_VER_WITHOUT_PROCESS_EXIT_CODE) {
		supportsProcessExitCode = false;
	}

	if (supportsProcessExitCode) {
		process.exitCode = exitCode;
	} else if (exitCode !== 0) {
		process.exit(exitCode);
	}
}


/*
 * Set stdout and stderr blocking and then `process.exit()` asynchronously to
 * allow stdout and stderr to flush before process termination.
 *
 * Call this function as follows:
 *      exeunt([code]);
 *      return;
 * instead of:
 *      process.exit([code]);
 * to attempt to ensure stdout/stderr are flushed before exiting.
 *
 * Note that this isn't perfect. See the README.md for considerations. This
 * function corresponds to "Solution 4" described there.
 *
 * @param {Number} code - Optional exit code. Defaults to 0.
 */
function exeunt__refinery(code) {
	var exitCode = code || 0;

	// Set stdout and stderr to be blocking *before* we exit...
	setBlocking__refinery();

	// ...then exit. However, we must do so in a way that node (libuv) will
	// do another pass through the event loop to handle async IO (in
	// `uv__io_poll`).
	setImmediate(function processExit() {
		process.exit(exitCode);
	});
}
