backpack = {};

function return_result( program_output ) {
	console.log(
		"<REFINERY_OUTPUT_CUSTOM_RUNTIME_START_MARKER>" + JSON.stringify(
			program_output,
			false,
			4
		) + "<REFINERY_OUTPUT_CUSTOM_RUNTIME_END_MARKER>"
	);
}

(async function refinerySubproccessWrapper() {

	var input_data = JSON.parse( process.argv[2] );
	var lambda_input = input_data[ "lambda_input" ];
	backpack = input_data[ "backpack" ];
	try {
		var output = await main( lambda_input );
		return_result({
			"output": output,
			"backpack": backpack,
		});

		backpack = {};

		flushProcessOutputsAndExit__refinery(0);
	} catch ( e ) {
		if( e.stack ) {
			e = e.stack.toString()
		} else {
			e = e.toString();
		}
		console.log(
			"<REFINERY_ERROR_OUTPUT_CUSTOM_RUNTIME_START_MARKER>" + JSON.stringify({
				"output": e,
				"backpack": backpack
			}) + "<REFINERY_ERROR_OUTPUT_CUSTOM_RUNTIME_END_MARKER>"
		);
		backpack = {};

		flushProcessOutputsAndExit__refinery(-1);
	}
})();

function flushProcessOutputsAndExit__refinery(exitCode) {
	// Configure the streams to be blocking
	makeBlockingStream__refinery(process.stdout);
	makeBlockingStream__refinery(process.stderr);


	// Allow Node to cleanup any internals before the next process tick
	setImmediate(function callProcessExitWithCode() {
		process.exit(exitCode);
	});
}

function makeBlockingStream__refinery(stream) {
	if (!stream || !stream._handle || !stream._handle.setBlocking) {
		// Not able to set blocking so just bail out
		return;
	}

	stream._handle.setBlocking(true);
}
